# [ğŸ‘©ğŸ»â€ğŸ’»ë¬¸ì œë§í¬](https://www.acmicpc.net/problem/16234)

[ë°±ì¤€ 16234] ì¸êµ¬ ì´ë™ (Python)
[![ë°±ì¤€](../ë°±ì¤€í‘œì§€.png)](https://www.acmicpc.net/problem/16234)

<br>

# âœï¸Idea Sketch

### **2021-08-09**

#### 1. ì´ë²ˆ ë¬¸ì œëŠ” 80% ì—ì„œ ì‹œê°„ ì´ˆê³¼ê°€ ë°œìƒí•´ ì• ë¥¼ ë¨¹ì€ ë¬¸ì œë‹¤.
- Python3ì—ëŠ” ì•½ 1000íšŒì˜ ì¬ê·€ ì œí•œì´ ìˆë‹¤. 
- PyPy3ëŠ” ì¬ê·€ ì œí•œ íšŸìˆ˜ê°€ ë” ì»¤ì„œ í†µê³¼í•  ìˆ˜ ìˆì—ˆë‹¤.

```Python
import sys
sys.setrecursionlimit(10**6)
```

#### 2. BFSì™€ DFS
- DFS, BFS ë‘˜ ì¤‘ ì–´ëŠ ê²ƒì„ í•´ë„ ìƒê´€ì—†ì§€ë§Œ
- BFSë¡œ êµ¬í˜„í•œ ì‚¬ë¡€ê°€ ë§ë‹¤.
- ì´ë²ˆì— DFSë¡œ êµ¬í˜„í•´ë´¤ëŠ”ë° ì¬ê·€ ì œí•œìœ¼ë¡œ ì• ë¥¼ ë§ì´ ë¨¹ì—ˆë‹¤.
- ë‹¤ì‹œ ì´ ë¬¸ì œë¥¼ ë³¸ë‹¤ë©´ BFSë¡œ êµ¬í˜„í•´ë³¼ ê²ƒ.

#### 3. ë¡œì§ ì´í•´í•˜ê¸°
- [ë¡œì§ ì´í•´ì— ë§ì€ ë„ì›€ì´ ëœ ë§ˆì´êµ¬ë¯¸ë‹˜ ë¸”ë¡œê·¸](https://mygumi.tistory.com/338)
- `dfs(x, y)` : ìƒí•˜ì¢Œìš° ì¸ì ‘í•œ ë‚˜ë¼ì™€ ì¸êµ¬ ì°¨ì´ë¥¼ í™•ì¸í•œë‹¤.
- `flag` : ì¸ì ‘í•œ ë‚˜ë¼ê°€ ìˆëŠ” ê²½ìš° `True`ë¥¼ ë°˜í™˜í•œë‹¤. 
- `main` : ì—°í•©í•œ ë‚˜ë¼ì˜ ì¢Œí‘œ `group`ê³¼ ì´ ì¸êµ¬ ìˆ˜ `sum`ì„ ì •ì˜í•œë‹¤.
- `exit` 
  1) ì¸ì ‘í•œ ë‚˜ë¼ê°€ ìˆëŠ” ê²½ìš° `False`, graphì— ì¸êµ¬ ì´ë™ì„ ë°˜ì˜í•œë‹¤.
  2) ì¸ì ‘í•œ ë‚˜ë¼ê°€ ì—†ê³  graph íƒìƒ‰ì„ ëë‚¸ ê²½ìš° `True`, whileë¬¸ì„ ì¢…ë£Œí•œë‹¤.

<br>

# âœï¸ì†ŒìŠ¤ì½”ë“œ

### **2021-08-09**
- Python3ë¡œ ì œì¶œí•  ê²½ìš° 80%ì—ì„œ **ì‹œê°„ ì´ˆê³¼**
- PyPy3ë¡œ ì œì¶œí•  ê²½ìš° 900ms **í†µê³¼**

```Python
import sys

def dfs(x, y):
  global sum
  flag = False
  if (0<=x<n) and (0<=y<n):
    visit[x][y] = 1
    if (0<=x-1<n) and (0<=y<n):
      if visit[x-1][y] == 0:
        if l <= abs(graph[x][y] - graph[x-1][y]) <= r:
          group.append([x-1, y])
          sum += graph[x-1][y]
          flag = True
          dfs(x-1, y)
    if (0<=x+1<n) and (0<=y<n):
      if visit[x+1][y] == 0:
        if l <= abs(graph[x][y] - graph[x+1][y]) <= r:
          group.append([x+1, y])
          sum += graph[x+1][y]
          flag = True
          dfs(x+1, y)
    if (0<=x<n) and (0<=y-1<n):
      if visit[x][y-1] == 0:
        if l <= abs(graph[x][y] - graph[x][y-1]) <= r:
          group.append([x, y-1])
          sum += graph[x][y-1]
          flag = True
          dfs(x, y-1)
    if (0<=x<n) and (0<=y+1<n):
      if visit[x][y+1] == 0:
        if l <= abs(graph[x][y] - graph[x][y+1]) <= r:
          group.append([x, y+1])
          sum += graph[x][y+1]
          flag = True
          dfs(x, y+1)
  return (group, sum, flag)


if __name__ == '__main__':
  n, l, r = map(int, input().split())
  graph = [list(map(int, sys.stdin.readline().rstrip().split())) for _ in range(n)]
  result = 0

  while True:
    visit = [[0 for _ in range(n)] for _ in range(n)]
    result += 1
    exit = True
    for i in range(n):
      for j in range(n):
        if visit[i][j] == 0:
          group = [[i, j]]
          sum = graph[i][j]
          group, sum, flag = dfs(i, j)
          if flag == True:
            exit = False
            for x, y in group:
              graph[x][y] = int(sum/len(group))
    if exit == True:
      print(result-1)
      break
```

<br>

# âœï¸ëª…ë‹µ

### BFS ë¡œì§

```Python
import sys
from collections import deque
input = sys.stdin.readline


dy = [1, -1, 0, 0] 
dx = [0, 0, 1, -1]


def bfs(y, x):
    global visisted, m
    queue = deque()
    queue.append((y, x))
    sum_val = m[y][x]
    visisted[y][x] = 1
    pos = [(y, x)]

    while queue:
        y, x = queue.popleft()

        for my, mx in zip(dy, dx):
            ny = y + my
            nx = x + mx
            if 0 <= ny < N and 0 <= nx < N and not visisted[ny][nx]:
                if L <= abs(m[ny][nx] - m[y][x]) <= R:
                    visisted[ny][nx] = 1
                    sum_val += m[ny][nx]
                    queue.append((ny, nx))
                    pos.append((ny, nx))
        
    if len(pos) > 1:  # exist group
        cnt = len(pos)
        mean = sum_val // cnt
        for i in range(cnt):
            y, x = pos[i] 
            m[y][x] = mean
            q.append((y, x))
        return 0
    else:
        return 1


def check(y, x):
    for my, mx in zip(dy, dx):
        ny = y + my
        nx = x + mx
        if 0 <= ny < N and 0 <= nx < N:
            if L <= abs(m[ny][nx] - m[y][x]) <= R:
                return 0
    return 1


N, L, R = map(int, input().split())
m = [[] for _ in range(N)]
q = deque()
for i in range(N):
    m[i] = list(map(int, input().split()))
    for j in range(N):
        q.append((i, j))

cnt = 0
flag = False 

while not flag:
    visisted = [[0] * N for _ in range(N)]
    flag = True
    size = len(q)
    for _ in range(size):
        y, x = q.popleft()
        if visisted[y][x] or check(y, x):
            continue
        if not bfs(y, x):
            flag = False 
    if not flag:
        cnt += 1
print(cnt)
```